# Targets:
#   yugen - the Yugen game binary
#   yedit - the Yedit editor binary
#   clean - delete all outputs
# Pass DBG=1 to make for debug binaries.
.SUFFIXES:

# Compilers and interpreters.
SHELL= \
	/bin/sh
CXX= \
	g++-4.8
PROTOC= \
	./depend/protobuf_2_5_0/bin/protoc

# Final outputs.
ifeq ($(DBG), 1)
OUTDIR=dbg
else
OUTDIR=bin
endif
YUGEN= \
	./$(OUTDIR)/yugen
YEDIT= \
	./$(OUTDIR)/yedit

# Compiler flags.
CFLAGS= \
	-isystem ./depend/boost_1_53_0/include \
	-isystem ./depend/sfml_2_0/include \
	-isystem ./depend/luajit_2_0_2/include \
	-isystem ./depend/protobuf_2_5_0/include \
	\
	-std=c++11
LFLAGS= \
	-L./depend/boost_1_53_0/lib \
	-L./depend/sfml_2_0/lib \
	-L./depend/luajit_2_0_2/lib \
	-L./depend/protobuf_2_5_0/lib \
	\
	-Wl,-Bstatic \
	-lboost_filesystem -lboost_iostreams -lboost_system \
	-lsfml-graphics-s -lsfml-window-s -lsfml-system-s \
	-lprotobuf \
	-lluajit-5.1 \
	-lz -lbz2 \
	\
	-Wl,-Bdynamic \
	-lGLEW -lGL -lX11 -lXrandr -ljpeg -lpthread -ldl
PFLAGS= \
	-I=./source/proto \
	--cpp_out=./gen/proto
ifeq ($(DBG), 1)
CFLAGS += -O3
else
CFLAGS += -Og \
	-Werror -Wall -Wextra -Wpedantic \
	-DLUA_DEBUG -DGL_DEBUG
endif

# File listings.
PROTOS= \
	$(wildcard ./source/proto/*.proto)
PROTO_SOURCES= \
	$(subst ./source/,./gen/,$(PROTOS:.proto=.pb.cc))
PROTO_HEADERS= \
	$(subst ./source/,./gen/,$(PROTOS:.proto=.pb.h))
SOURCES= \
	$(wildcard ./source/*.cpp) \
	$(wildcard ./source/*/*.cpp) \
	$(wildcard ./source/*.cc) \
	$(wildcard ./source/*/*.cc) \
	$(PROTO_SOURCES)
HEADERS= \
	$(wildcard ./source/*.h) \
	$(wildcard ./source/*/*.h) \
	$(PROTO_HEADERS)
DEPFILES= \
  $(addprefix ./$(OUTDIR)/,\
	$(addsuffix .deps,$(SOURCES)))
OBJECTS= \
  $(addprefix ./$(OUTDIR)/,\
	$(patsubst %.cc,%.cc.o,\
	$(patsubst %.cpp,%.cpp.o,$(SOURCES))))
YUGEN_OBJECTS= \
	$(filter-out ./%/yedit.cpp.o,$(OBJECTS))
YEDIT_OBJECTS= \
	$(filter-out ./%/yugen.cpp.o,$(OBJECTS))

# Master targets.
.PHONY: all
all: \
	$(YUGEN) $(YEDIT)
.PHONY: proto
proto: \
	$(PROTO_SOURCES) $(PROTO_HEADERS)
.PHONY: yugen
yugen: \
	$(YUGEN)
.PHONY: yedit
yedit: \
	$(YEDIT)
.PHONY: clean
clean:
	@rm -rf ./$(OUTDIR)
	@rm -rf ./gen

# Dependency generation. Each source file generates a corresponding .deps file
# (a Makefile containing a .build target), which is then included. Inclusion
# forces regeneration via the rules provided.
#
# Ridiculous magic: the .deps rule depends on same .build target it generates.
# This means we only need to regenerate dependencies when a dependency changes.
# When the specific .build target doesn't exist, the default causes everything
# to be generated.
./$(OUTDIR)/%.deps: \
	./$(OUTDIR)/%.build ./$(OUTDIR)/%.mkdir ./deps.sh
	@SOURCE_FILE=$(subst ./$(OUTDIR)/,,./$(@:.deps=)); \
	    echo Generating dependencies for $$SOURCE_FILE; \
	    ./deps.sh $@ $< $$SOURCE_FILE
.PRECIOUS: ./$(OUTDIR)/%.build
./$(OUTDIR)/%.build: \
	./% $(HEADERS) ./$(OUTDIR)/%.mkdir
	@touch $@

ifneq ('$(MAKECMDGOALS)', 'clean')
-include $(DEPFILES)
endif

# Binaries.
$(YUGEN): \
	$(YUGEN_OBJECTS)
	@echo Linking ./$@
	@$(CXX) -o ./$@ $^ $(LFLAGS)
$(YEDIT): \
	$(YEDIT_OBJECTS)
	@echo Linking ./$@
	@$(CXX) -o ./$@ $^ $(LFLAGS)

# Object files. Each object file depends on a .build target contained in the
# autogenerated dependency files. The .build target depends on the source file
# and any header files it needs. The extra level of indirection makes the
# autogeneration much nicer.
./$(OUTDIR)/%.o: \
	./$(OUTDIR)/%.build ./$(OUTDIR)/%.mkdir
	@SOURCE_FILE=$(subst ./$(OUTDIR)/,,./$(<:.build=)); \
	    echo Compiling $$SOURCE_FILE; \
	    $(CXX) -c $(CFLAGS) -o $@ $$SOURCE_FILE

# Proto files. These are generated in pairs, so we have a little bit of trickery
# to make that work right.
./gen/proto/%.pb.cc: \
	./gen/proto/%.pb.h
	@touch $@ $<
./gen/proto/%.pb.h: \
	./source/proto/%.proto ./gen/proto/.mkdir
	@echo Compiling ./$<
	@$(PROTOC) $(PFLAGS) ./$<

# Ensure a directory exists.
.PRECIOUS: ./%.mkdir
./%.mkdir:
	@mkdir -p $(dir $@)
	@touch $@
